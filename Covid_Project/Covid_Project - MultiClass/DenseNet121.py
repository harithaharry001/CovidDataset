# -*- coding: utf-8 -*-
"""DenseNet121

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/159deQX1vSWiHYn9pq78MUrKYsymxjEA0
"""

import tensorflow as tf
from tensorflow.keras.layers import Input, Conv2D, BatchNormalization, Dense
from tensorflow.keras.layers import AvgPool2D, GlobalAveragePooling2D, MaxPool2D
from tensorflow.keras.models import Model
from tensorflow.keras.layers import ReLU, concatenate
import tensorflow.keras.backend as K
import json
import pandas as pd
from keras.utils import to_categorical
from sklearn.utils import shuffle
from matplotlib.pyplot import imread
from keras.preprocessing import image

class DenseNet121:
    def __init__(self, X_train, X_test, Y_train, Y_test):
        self.X_train = X_train
        self.X_test = X_test
        self.Y_train = Y_train
        self.Y_test = Y_test
        self.x_train_normalization = None
        self.x_test_normalization = None
        self.y_train_one_hot = None
        self.y_test_one_hot = None
        self.x_shuffled_default = None
        self.y_shuffled_default = None
        
 #batch norm + relu + conv
    def bn_rl_conv(self,x,filters,kernel=1,strides=1):
        x = BatchNormalization()(x)
        x = ReLU()(x)
        x = Conv2D(filters, kernel, strides=strides,padding = 'same')(x)
        return x

    def dense_block(self,x, repetition,filters):

        for _ in range(repetition):
            y = self.bn_rl_conv(x, 4*filters)
            y = self.bn_rl_conv(y, filters, 3)
            x = concatenate([y,x])
        return x

    def transition_layer(self,x):

        x = self.bn_rl_conv(x, K.int_shape(x)[-1] //2 )
        x = AvgPool2D(2, strides = 2, padding = 'same')(x)
        return x

    def densenet(self,input_shape, n_classes, filters = 32):
    
        input = Input (input_shape)
        x = Conv2D(64, 7, strides = 2, padding = 'same')(input)
        x = MaxPool2D(3, strides = 2, padding = 'same')(x)
    
        for repetition in [6,12,24,16]:

            d = self.dense_block(x, repetition,filters)
            x = self.transition_layer(d)
        x = GlobalAveragePooling2D()(d)
        output = Dense(n_classes, activation = 'softmax')(x)

        model = Model(input, output,name='DenseNet-121')
        return model
    
    def execute_densenet121_model(self):
        model = self.densenet(input_shape = (224, 224, 3), n_classes = 5)
        model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
        return model

    def summary(self,model):
        model.summary()

    def image_processing(self):
        y_train_values, unique = pd.factorize(self.Y_train)
        # print('y_train ', y_train_values, unique)
        y_test_values, unique = pd.factorize(self.Y_test)
        print('y_test ', y_test_values, unique)

        self.y_train_one_hot = to_categorical(y_train_values)
        self.y_test_one_hot = to_categorical(y_test_values)

        self.x_train_normalization = self.X_train / 255.0
        self.x_test_normalization = self.X_test / 255.0

        self.x_shuffled_default, self.y_shuffled_default = shuffle(self.x_train_normalization, self.y_train_one_hot)



    def fit_model(self,model):
        history = model.fit(self.x_shuffled_default, self.y_shuffled_default, epochs = 30, batch_size = 32)
        with open('densenet.json', 'w') as file:
                json.dump(history.history, file)

    def evaluate_model(self,model):
        preds = model.evaluate(self.x_test_normalization, self.y_test_one_hot)
        print ("Loss = " + str(preds[0]))
        print ("Test Accuracy = " + str(preds[1]))


    def predict_model(self):
#         img_path = '/content/drive/MyDrive/NORMAL(1576).jpg'
#         img = image.load_img(img_path, target_size=(224, 224,3))
#         x = image.img_to_array(img)
#         x = np.expand_dims(x, axis=0)
#         x = preprocess_input(x)
#         print('Input image shape:', x.shape)
#         my_image = imread(img_path)
#         imshow(my_image)
#         print(model.predict(x))
        print("called")