# -*- coding: utf-8 -*-
"""ResNet50

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qh5dQggErliJw7xacfqUt785Fmxnu3Aq
"""

import tensorflow as tf
from tensorflow import keras
import numpy as np
from keras import layers
from keras.layers import Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D
from keras.models import Model, load_model
from keras.preprocessing import image
from keras.utils import layer_utils
from keras.utils.data_utils import get_file
from keras.applications.imagenet_utils import preprocess_input
import pydot
from IPython.display import SVG
from keras.utils.vis_utils import model_to_dot
from keras.utils import plot_model
from keras.initializers import glorot_uniform
import scipy.misc
from matplotlib.pyplot import imshow
from keras.initializers import glorot_uniform
from keras.layers import Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D
import pandas as pd
from keras.utils import to_categorical
from sklearn.utils import shuffle
import json
from matplotlib.pyplot import imread
from keras.preprocessing import image

class ResNet50:
    def __init__(self, X_train, X_test, Y_train, Y_test):
        self.X_train = X_train
        self.X_test = X_test
        self.Y_train = Y_train
        self.Y_test = Y_test
        self.x_train_normalization = None
        self.x_test_normalization = None
        self.y_train_one_hot = None
        self.y_test_one_hot = None
        self.x_shuffled_default = None
        self.y_shuffled_default = None
        

    def identity_block(self,X, f, filters):
        # Retrieve Filters
        F1, F2, F3 = filters  # F1=64,F2=64,256

        X_shortcut = X

        # First  layer
        X = Conv2D(filters = F1, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)
        X = BatchNormalization(axis = 3)(X)
        X = Activation('relu')(X)


        # Second  layer
        X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same')(X)
        X = BatchNormalization(axis = 3)(X)
        X = Activation('relu')(X)

        # Third  layer
        X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)
        X = BatchNormalization(axis = 3)(X)

        # Final step: Add shortcut value to F(X), and pass it through a RELU activation 
        X = Add()([X, X_shortcut])
        X = Activation('relu')(X)


        return X

    def convolutional_block(self,X, f, filters, s = 2):

    
        # Retrieve Filters
        F1, F2, F3 = filters

        # Save the input value
        X_shortcut = X


        # First layer 
        X = Conv2D(F1, (1, 1), strides = (s,s))(X) # 1,1 is filter size
        X = BatchNormalization(axis = 3)(X)  # normalization on channels
        X = Activation('relu')(X)


        # Second layer  (f,f)=3*3 filter by default
        X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same')(X)
        X = BatchNormalization(axis = 3)(X)
        X = Activation('relu')(X)


        # Third layer
        X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)
        X = BatchNormalization(axis = 3)(X)


        ##### SHORTCUT PATH #### 
        X_shortcut = Conv2D(filters = F3, kernel_size = (1, 1), strides = (s,s), padding = 'valid')(X_shortcut)
        X_shortcut = BatchNormalization(axis = 3)(X_shortcut)

        # Final step: Add shortcut value here, and pass it through a RELU activation 
        X = Add()([X, X_shortcut])
        X = Activation('relu')(X)


        return X

    def resnet_model(self):
        """
        Implementation of the ResNet50 architecture:
        CONV2D -> BATCHNORM -> RELU -> MAXPOOL -> CONVBLOCK -> IDBLOCK*2 -> CONVBLOCK -> IDBLOCK*3
        -> CONVBLOCK -> IDBLOCK*5 -> CONVBLOCK -> IDBLOCK*2 -> AVGPOOL -> TOPLAYER

        """
        input_shape=(224, 224, 3)
        classes=2
        # Define the input with shape input_shape
        X_input = Input(input_shape)

        # Zero-Padding
        X = ZeroPadding2D((3, 3))(X_input) #3,3 padding

        # Stage 1
        X = Conv2D(64, (7, 7), strides=(2, 2))(X) 
        X = BatchNormalization(axis=3)(X) 
        X = Activation('relu')(X)
        X = MaxPooling2D((3, 3), strides=(2, 2))(X)

        # Stage 2
        X = self.convolutional_block(X, f=3, filters=[64, 64, 256], s=1)

        # below 3 lines are the conv layers from convolutional_block function defined above
        #X = Conv2D(F1, (1, 1), strides = (s,s))(X)
        #X = Conv2D(F2, kernel_size = (f, f), strides = (1,1), padding = 'same')(X)
        #X = Conv2D(F3, (1, 1), strides = (s,s), name = conv_name_base + '2a')(X)

        X = self.identity_block(X, 3, [64, 64, 256]) 
        #X = Conv2D(filters = F1, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)
        #X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same')(X)
        #X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)

        X = self.identity_block(X, 3, [64, 64, 256])
        #X = Conv2D(filters = F1, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)
        #X = Conv2D(filters = F2, kernel_size = (f, f), strides = (1,1), padding = 'same')(X)
        #X = Conv2D(filters = F3, kernel_size = (1, 1), strides = (1,1), padding = 'valid')(X)


        # Stage 3 
        X = self.convolutional_block(X, f = 3, filters = [128, 128, 512], s = 2)
        X = self.identity_block(X, 3, [128, 128, 512])
        X = self.identity_block(X, 3, [128, 128, 512])
        X = self.identity_block(X, 3, [128, 128, 512])

        # Stage 4 
        X = self.convolutional_block(X, f = 3, filters = [256, 256, 1024], s = 2)
        X = self.identity_block(X, 3, [256, 256, 1024])
        X = self.identity_block(X, 3, [256, 256, 1024])
        X = self.identity_block(X, 3, [256, 256, 1024])
        X = self.identity_block(X, 3, [256, 256, 1024])
        X = self.identity_block(X, 3, [256, 256, 1024])

        # Stage 5 
        X = self.convolutional_block(X, f = 3, filters = [512, 512, 2048], s = 2)
        X = self.identity_block(X, 3, [512, 512, 2048])
        X = self.identity_block(X, 3, [512, 512, 2048])

        # AVGPOOL 
        X = AveragePooling2D((2,2), name="avg_pool")(X)

        ### END CODE HERE ###

        # output layer
        X = Flatten()(X)
        X = Dense(classes, activation='softmax', name='fc' + str(classes), kernel_initializer = glorot_uniform(seed=0))(X)


        # Create model
        model = Model(inputs = X_input, outputs = X, name='ResNet50')

        return model
   
    def execute_resnet50_model(self):
        model = self.resnet_model()
        model.compile(
            loss=keras.losses.binary_crossentropy,optimizer='adam',metrics=['accuracy'])
        return model

    def summary(self,model):
        model.summary()

    
    def image_processing(self):
        y_train_values, unique = pd.factorize(self.Y_train)
        # print('y_train ', y_train_values, unique)
        y_test_values, unique = pd.factorize(self.Y_test)
        print('y_test ', y_test_values, unique)

        self.y_train_one_hot = to_categorical(y_train_values)
        self.y_test_one_hot = to_categorical(y_test_values)

        self.x_train_normalization = self.X_train / 255.0
        self.x_test_normalization = self.X_test / 255.0

        self.x_shuffled_default, self.y_shuffled_default = shuffle(self.x_train_normalization, self.y_train_one_hot)


    def fit_model(self,model):
        history = model.fit(self.x_shuffled_default, self.y_shuffled_default, epochs = 30, batch_size = 32)
        with open('resnet.json', 'w') as file:
            json.dump(history.history, file)

    def evaluate_model(self,model):
        preds = model.evaluate(self.x_test_normalization,self.y_test_one_hot)
        print ("Loss = " + str(preds[0]))
        print ("Test Accuracy = " + str(preds[1]))

    def predict_model(self):
#         img_path = '/content/drive/MyDrive/NORMAL(1576).jpg'
#         img = image.load_img(img_path, target_size=(224, 224,3))
#         x = image.img_to_array(img)
#         x = np.expand_dims(x, axis=0)
#         x = preprocess_input(x)
#         print('Input image shape:', x.shape)
#         my_image = imread(img_path)
#         imshow(my_image)
#         print(model.predict(x))
        print("called")